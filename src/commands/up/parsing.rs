//! This code works around incompatibilities between Clap 4 and `spin up`'s
//! messy trigger argument handling.
//!
//! It preprocesses the argument strings, splitting off those arguments
//! recognized by `spin up` itself by introspecting the arguments generated by
//! `UpCommandInner`'s `#[derive(Parser)]`.

use std::{
    collections::HashMap,
    ffi::{OsStr, OsString},
};

use clap::{Args, Command, CommandFactory, Parser};

use super::{UpCommand, UpCommandInner};

impl Args for UpCommand {
    fn augment_args(cmd: clap::Command) -> clap::Command {
        // The FromArgMatches impl below depends on some restrictions on
        // UpCommandInner, which we assert here to prevent bugs
        for arg in UpCommandInner::command().get_arguments() {
            assert!(
                !arg.is_positional(),
                "UpCommandInner cannot use positional arg {arg}"
            );
            let num_args = arg.get_num_args().unwrap_or_default();
            assert!(
                num_args.min_values() == num_args.max_values(),
                "UpCommandInner cannot use args with variable number of values"
            );
        }

        // Grab all arguments for later parsing
        cmd.disable_help_flag(true).arg(
            clap::Arg::new("args")
                .action(clap::ArgAction::Append)
                .allow_hyphen_values(true),
        )
    }

    fn augment_args_for_update(_: clap::Command) -> clap::Command {
        unimplemented!("UpCommand cannot be flattened")
    }
}

impl clap::FromArgMatches for UpCommand {
    fn from_arg_matches(matches: &clap::ArgMatches) -> std::result::Result<Self, clap::Error> {
        let cmd = UpCommandInner::command();

        // Build our own maps of flags -> arguments, because clap doesn't like to share
        let mut long_flags = HashMap::new();
        let mut short_flags = HashMap::new();
        for arg in cmd.get_arguments() {
            for long in arg
                .get_long()
                .into_iter()
                .chain(arg.get_all_aliases().unwrap_or_default())
            {
                long_flags.insert(long, arg);
            }
            for short in arg
                .get_short()
                .into_iter()
                .chain(arg.get_all_short_aliases().unwrap_or_default())
            {
                short_flags.insert(short, arg);
            }
        }

        // Use clap's own lexer against it
        let raw_args = clap_lex::RawArgs::new(matches.get_raw("args").into_iter().flatten());
        let mut cursor = raw_args.cursor();

        // Split the arguments into those recognized by UpInnerCommand and all
        // others. As a general strategy if we see something unexpected at this
        // stage we let it through with the expectation that later parsing will
        // catch it and produce a nice clap error.
        let mut up_args = vec!["spin up".into()];
        let mut trigger_args = vec![];
        while let Some(parsed) = raw_args.next(&mut cursor) {
            // --long flags
            if let Some((Ok(long), eq_value)) = parsed.to_long() {
                if let Some(arg) = long_flags.get(long) {
                    up_args.push(parsed.to_value_os().to_os_string());
                    // We asserted earlier that there are a fixed number of values
                    let mut need_args = arg.get_num_args().map_or(0, |na| na.min_values());
                    // For --key=value args `value` needs to be counted
                    if need_args > 0 && eq_value.is_some() {
                        need_args -= 1;
                    }
                    // Grab any required value(s)
                    for _ in 0..need_args {
                        up_args.extend(raw_args.next_os(&mut cursor).map(ToOwned::to_owned));
                    }
                } else {
                    trigger_args.push(parsed.to_value_os().into());
                }
            // -short flags; note that clap allows "stacked" flags, i.e. `-abc` == `-a -b -c`
            } else if let Some(shorts) = parsed.to_short() {
                for short_res in shorts {
                    match short_res {
                        Ok(short) if short_flags.contains_key(&short) => {
                            up_args.push(format!("-{short}").into());
                        }
                        Ok(short) => {
                            trigger_args.push(format!("-{short}").into());
                        }
                        Err(invalid) => {
                            trigger_args.push(OsString::from_iter([OsStr::new("-"), invalid]));
                        }
                    }
                }
            } else {
                // We asserted that UpCommandInner has no positional args
                trigger_args.push(parsed.to_value_os().into());
            }
        }

        let mut inner = UpCommandInner::try_parse_from(up_args)?;
        inner.trigger_args = trigger_args;
        Ok(Self(inner))
    }

    fn update_from_arg_matches(
        &mut self,
        _: &clap::ArgMatches,
    ) -> std::result::Result<(), clap::Error> {
        unimplemented!("UpCommand cannot be flattened")
    }
}

impl Parser for UpCommand {}

impl CommandFactory for UpCommand {
    fn command() -> clap::Command {
        Self::augment_args(Command::default())
    }

    fn command_for_update() -> clap::Command {
        unimplemented!("UpCommand cannot be flattened")
    }
}
